<!DOCTYPE html>
<html>
  <head>
    <script src="lib/jquery-1.11.2.min.js"></script>
    <script src="lib/marchingsquares.js"></script>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <textarea class="ffjs hiddenCode">
        load "ppm2rnm"


// ========================================================
// Création du maillage
// ========================================================

// Paramètres
int nbtj=20; // Nb de triangles autour de chaque objet
int nbtbord=10; // Nb de triangles aux bords du domaine


int nx = 31;
int ny = 31;
    
// Maillage pour isoline
mesh Th = square(nx-1, ny-1, [(nx-1)*(x), (ny-1)*(1-y)]);

// Fespace
fespace Vh(Th, P1);





border C01(t=0, 1){x = t*(nx-1);y = 0;label=3;}  // Sud
border C02(t=0, 1){x = nx-1;y = t*(ny-1);label=4;}  // Est
border C03(t=0, 1){x = (1-t)*(nx-1);y = (ny-1);label=5;}  // Nord
border C04(t=0, 1){x = 0;y = (1-t)*(ny-1);label=6;}  // Ouest



    </textarea>
    <textarea id="buildShape" class="ffjs hiddenCode"> </textarea>
    <textarea class="ffjs hiddenCode">
      plot(Th, ps="figure.eps");


      // ========================================================
      // Résolution du problème
      // ========================================================

      // Paramètres
      // real nu = 1.56e-5;
      real nu = 1.;
      real dt = 0.1;
      real T = 1.;  // Temps final
      int i;
      int choix = 2;  // Pour le choix du schéma

      // Fespace
      fespace Uh(Th,P2);  // Espace pour la vélocité
      Uh u1, u2, v1, v2;
      Uh u1old, u2old;

      fespace Ph(Th,P1);  // Espace pour la pression
      Ph p, q;

      // Problème de Navier-Stokes
      // Par linéarisation
      problem NavierStokes1(u1, u2, p, v1, v2, q, solver=Crout, init = i)
          =   int2d(Th)
              (
                      (u1*v1 + u2*v2)/dt
                  +   nu*(dx(u1)*dx(v1) + dy(u1)*dy(v1)
                      +   dx(u2)*dx(v2) + dy(u2)*dy(v2))
                  - p*dx(v1) - p*dy(v2)
                  - q*dx(u1) - q*dy(u2)
                  - p*q*(0.000001)  // Pour la stabilité et permet d'utiliser le solveur Crout
              )
            + int2d(Th)
              (
                  - u1old*v1/dt - u2old*v2/dt
              )
            + int2d(Th)
              (
                  u1old*(dx(u1)*v1 + dy(u1)*v2)
                  + u2old*(dx(u2)*v1 + dy(u2)*v2)
              )
            + on(1, 2, u1=0, u2=0)  // Conditions de Dirichlet sur les avions
            + on(4,5,6, u1=0, u2=-10)  // Conditions de Dirichlet à l'Est, au Nord et à l'Ouest
          ;

      // Méthode des caractéristiques
      problem NavierStokes2(u1, u2, p, v1, v2, q, solver = Crout, init = i)
          =   int2d(Th)
              (
                      (u1*v1 + u2*v2)/dt
                  +   nu*(dx(u1)*dx(v1) + dy(u1)*dy(v1)
                      +   dx(u2)*dx(v2) + dy(u2)*dy(v2))
                  - p*dx(v1) - p*dy(v2)
                  - q*dx(u1) - q*dy(u2)
                  - p*q*(0.000001)  // Pour la stabilité et permet d'utiliser le solveur Crout
              )
            + int2d(Th)
              (
                  -   convect([u1old, u2old], -dt, u1old)*v1/dt
                  -   convect([u1old, u2old], -dt, u2old)*v2/dt
              )
            + on(1, 2, 7, 8, 9, 10, u1=0, u2=0)  // Conditions de Dirichlet sur les avions
            + on(4,5,6, u1=0, u2=-10)  // Conditions de Dirichlet à l'Est, au Nord et à l'Ouest
          ;


      // Boucle pour le temps
      u1 = 0;
      u2 = 0;
      p=0;

      i = 0;
      for (real t = 0; t <= T; t += dt)
      {
          if (i%10 == 0) i=0;  // On recalcule la matrice tous les 10 pas de temps
          if (choix == 1)
          {
              u1old = u1;
              u2old = u2;
              NavierStokes1;           
        NavierStokes1;           
              NavierStokes1;           
          }
              
          else if (choix == 2)
          {
              u1old = u1;
              u2old = u2;
              NavierStokes2;
          }
          i++;
      }
      plot([u1,u2],p, cmm="t = "+T, value=1);
    </textarea>

    <button type="button" onclick="run()">Run</button>
    <button type="button" onclick="clearDrawing()">Clear</button>
    <!-- <button type="button" onclick="getIsoline()">get isoline</button> -->
    <!-- <button type="button" onclick="ffjs_reset()">Reset</button> -->

    <canvas
      id="inputCanvas"
      style="border: 2px solid red"
      width="300px"
      height="300px"
    ></canvas>

    <div style="display: flex">
      <canvas
        class="ffjs_graph"
        data-ffjs="figure.eps"
        width="500px"
        height="500px"
        style="width: 100%"
      >
        (message for older browsers where canvas is not implemented)
      </canvas>
      <canvas
        class="ffjs_graph"
        data-ffjs="default"
        width="500px"
        height="500px"
        style="width: 100%"
      >
        (message for older browsers where canvas is not implemented)
      </canvas>
    </div>
    <div id="ffjs_stdout" style="font-family: monospace"></div>
    <div id="ffjs_stderr" style="font-family: monospace"></div>

    <div id="askPermission">
      <div class="modal-content">
        <p>This page needs to load a solver for differential equations.</p>
        <p>
          60MB will be loaded, we recomand you to use WIFI instead of 3G, 4G or
          even 5G.
        </p>
        <button onclick="loadLibraries()">load this bog file &lt;3</button>
      </div>
    </div>

    <script>
      function loadLibraries() {
        const script1 = document.createElement("script");
        const script2 = document.createElement("script");
        document.head.appendChild(script1);
        document.head.appendChild(script2);
        script1.type = "text/javascript";
        script2.type = "text/javascript";
        script1.src = "lib/freefem.min.js";
        script2.src = "lib/ffapi.js";

        script1.onload = function (e) {
          // finish loading the script
          document.getElementById("askPermission").remove();
        };
      }

      var c = document.getElementById("inputCanvas");
      var ctx = c.getContext("2d");
      var points = [];

      var codeFreeFem = document.getElementById("buildShape");

      function getShape(points, curveIndex) {
        if (points.length <= 1) {
          return "";
        }
        const nbPoints = points.length;
        let totalDist = 0;
        const lastDist = Math.sqrt(
          (points[0].x - points[points.length - 1].x) ** 2 +
            (points[0].y - points[points.length - 1].y) ** 2
        );

        let rep = "";

        rep += `
              real[int, int] Curves${curveIndex}(3, ${nbPoints + 1});


              ${points
                .map(({ x, y }, index) => {
                  if (index === 0) {
                    return `Curves${curveIndex}(0, 0) = ${(x + 5) / 10};
              Curves${curveIndex}(1, 0) = ${(305 - y) / 10};
              Curves${curveIndex}(2, 0) = 0.;

                  `;
                  } else {
                    const dx = x - points[index - 1].x;
                    const dy = y - points[index - 1].y;
                    const d = Math.sqrt(dx ** 2 + dy ** 2);
                    totalDist += d;
                    return `
              Curves${curveIndex}(0, ${index}) = ${(x + 5) / 10};
              Curves${curveIndex}(1, ${index}) = ${(305 - y) / 10};
              Curves${curveIndex}(2, ${index}) = ${totalDist / 10};

                  `;
                  }
                })
                .join("")}

              Curves${curveIndex}(0, ${points.length}) = ${
          (points[0].x + 5) / 10
        };
              Curves${curveIndex}(1, ${points.length}) = ${
          (305 - points[0].y) / 10
        };
              Curves${curveIndex}(2, ${points.length}) = ${
          (totalDist + lastDist) / 10
        };`;

        rep += `
        border jet${curveIndex}(t=0, 1)
       {
          int c=0;
          int i = 0;
          if( t== 1){
              x = Curves${curveIndex}(0, ${nbPoints});
              y = Curves${curveIndex}(1, ${nbPoints});
          }
          else{
          while(Curves${curveIndex}(2, i) <= Curves${curveIndex}(2, ${nbPoints}) * t ){
              i += 1;
          }
              x=(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, ${nbPoints})*t)/(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, i-1)) * Curves${curveIndex}(0, i-1) + (Curves${curveIndex}(2, ${nbPoints})*t - Curves${curveIndex}(2, i-1))/(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, i-1)) * Curves${curveIndex}(0, i);
              y=(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, ${nbPoints})*t)/(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, i-1)) * Curves${curveIndex}(1, i-1) + (Curves${curveIndex}(2, ${nbPoints})*t - Curves${curveIndex}(2, i-1))/(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, i-1)) * Curves${curveIndex}(1, i);

          }
          label=${curveIndex};
      }`;
        return rep;
      }

      function getShapes(listOfPoints) {
        let rep = "";

        let label = 1;
        const usedLabels = [];
        listOfPoints.forEach((points) => {
          const sol = getShape(
            points.map((_, i) => points[points.length - i - 1]),
            label
          );
          if (sol !== "") {
            usedLabels.push(label);
            label += 1;
            if (label == 3) {
              label = 7;
            }
            rep += sol;
          }
        });

        rep += `
        // Maillage pour les calculs
        Th = buildmesh(${usedLabels
          .map((l) => `jet${l}(-nbtj)`)
          .join("+")}+C01(nbtbord)+C02(nbtbord)+C03(nbtbord)+C04(nbtbord));
        `;
        return rep;
      }

      c.onmousemove = function (ev) {
        if (ev.buttons === 1) {
          ctx.beginPath();
          ctx.arc(ev.layerX, ev.layerY, 10, 0, Math.PI * 2, true);
          ctx.fill();
        }
      };

      function clearDrawing() {
        points = [];
        ctx.clearRect(0, 0, c.width, c.height);
      }

      function getIsoline() {
        const data = ctx.getImageData(5, 5, 300, 300).data;

        const newArr = [];
        for (let i = 0; i < data.length; i += 4 * 300) {
          newArr.push(
            Array.from(data.slice(i, i + 4 * 300)).filter(
              (x, index) => index % 4 === 3
            )
          );
        }
        const rep = MarchingSquaresJS.isoLines(newArr, [1, 100, 300], {
          noFrame: true,
        });

        rep[1].forEach((subRep, index) => {
          ctx.beginPath();
          ctx.moveTo(5 + rep[1][0][0], 5 + rep[1][0][1]);
          subRep.forEach(([x, y]) => {
            ctx.lineTo(5 + x, 5 + y);
          });
          ctx.strokeStyle = "red";
          ctx.stroke();
        });

        return rep[1].map((l) => l.map(([x, y]) => ({ x, y })));
      }

      function run() {
        const listOfPoints = getIsoline();
        codeFreeFem.innerHTML = getShapes(listOfPoints);
        ffjs_evaluate();
      }
    </script>
  </body>
</html>
