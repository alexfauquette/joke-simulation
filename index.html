<!DOCTYPE html>
<html>
  <head>
    <script src="lib/jquery-1.11.2.min.js"></script>
    <script src="lib/marchingsquares.js"></script>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <textarea class="ffjs hiddenCode">
        load "ppm2rnm"


// ========================================================
// Création du maillage
// ========================================================

// Paramètres
int nbtj=20; // Nb de triangles autour de chaque objet
int nbtbord=10; // Nb de triangles aux bords du domaine


int nx = 31;
int ny = 31;
    
// Maillage pour isoline
mesh Th = square(nx-1, ny-1, [(nx-1)*(x), (ny-1)*(1-y)]);

// Fespace
fespace Vh(Th, P1);





border C01(t=0, 1){x = t*(nx-1);y = 0;label=3;}  // Sud
border C02(t=0, 1){x = nx-1;y = t*(ny-1);label=4;}  // Est
border C03(t=0, 1){x = (1-t)*(nx-1);y = (ny-1);label=5;}  // Nord
border C04(t=0, 1){x = 0;y = (1-t)*(ny-1);label=6;}  // Ouest



    </textarea>
    <textarea id="buildShape" class="ffjs hiddenCode"> </textarea>
    <textarea class="ffjs hiddenCode">
      plot(Th, ps="figure.eps");


      // ========================================================
      // Résolution du problème
      // ========================================================

      // Paramètres
      // real nu = 1.56e-5;
      real nu = 1.;
      real dt = 0.1;
      real T = 1.;  // Temps final
      int i;
      // Fespace
      fespace Uh(Th,P2);  // Espace pour la vélocité
      Uh u1, u2, v1, v2;
      Uh u1old, u2old;

      fespace Ph(Th,P1);  // Espace pour la pression
      Ph p, q;

      // Problème de Navier-Stokes
      // Par linéarisation
      problem NavierStokes1(u1, u2, p, v1, v2, q, solver=Crout, init = i)
          =   int2d(Th)
              (
                      (u1*v1 + u2*v2)/dt
                  +   nu*(dx(u1)*dx(v1) + dy(u1)*dy(v1)
                      +   dx(u2)*dx(v2) + dy(u2)*dy(v2))
                  - p*dx(v1) - p*dy(v2)
                  - q*dx(u1) - q*dy(u2)
                  - p*q*(0.000001)  // Pour la stabilité et permet d'utiliser le solveur Crout
              )
            + int2d(Th)
              (
                  - u1old*v1/dt - u2old*v2/dt
              )
            + int2d(Th)
              (
                  u1old*(dx(u1)*v1 + dy(u1)*v2)
                  + u2old*(dx(u2)*v1 + dy(u2)*v2)
              )
            + on(1, 2, 7, 8, 9, 10, u1=0, u2=0)  // Conditions de Dirichlet sur les avions
            + on(wall1, wall2, wall3, u1=Vx, u2=Vy)  // Conditions de Dirichlet à l'Est, au Nord et à l'Ouest
          ;

      // Méthode des caractéristiques
      problem NavierStokes2(u1, u2, p, v1, v2, q, solver = Crout, init = i)
          =   int2d(Th)
              (
                      (u1*v1 + u2*v2)/dt
                  +   nu*(dx(u1)*dx(v1) + dy(u1)*dy(v1)
                      +   dx(u2)*dx(v2) + dy(u2)*dy(v2))
                  - p*dx(v1) - p*dy(v2)
                  - q*dx(u1) - q*dy(u2)
                  - p*q*(0.000001)  // Pour la stabilité et permet d'utiliser le solveur Crout
              )
            + int2d(Th)
              (
                  -   convect([u1old, u2old], -dt, u1old)*v1/dt
                  -   convect([u1old, u2old], -dt, u2old)*v2/dt
              )
            + on(1, 2, 7, 8, 9, 10, u1=0, u2=0)  // Conditions de Dirichlet sur les avions
            + on(wall1, wall2, wall3, u1=Vx, u2=Vy)  // Conditions de Dirichlet à l'Est, au Nord et à l'Ouest
          ;


      // Boucle pour le temps
      u1 = 0;
      u2 = 0;
      p=0;

      i = 0;
      for (real t = 0; t <= T; t += dt)
      {
          if (i%10 == 0) i=0;  // On recalcule la matrice tous les 10 pas de temps
          if (choix == 1)
          {
              u1old = u1;
              u2old = u2;
              NavierStokes1;           
          }
              
          else if (choix == 2)
          {
              u1old = u1;
              u2old = u2;
              NavierStokes2;
          }
          i++;
      }
      plot([u1,u2],p, cmm="t = "+T, value=1);
    </textarea>

    <button type="button" onclick="run()">Run</button>
    <button type="button" onclick="clearDrawing()">Clear</button>
    <!-- <button type="button" onclick="getIsoline()">get isoline</button> -->
    <!-- <button type="button" onclick="ffjs_reset()">Reset</button> -->

    <canvas
      id="inputCanvas"
      style="border: 2px solid red"
      width="300px"
      height="300px"
    ></canvas>
    <canvas
      id="penSize"
      style="border: 2px solid black"
      width="50px"
      height="50px"
    ></canvas>
    <input
      type="range"
      min="1"
      max="20"
      value="10"
      class="slider"
      oninput="updatPenSize(this.value)"
    />

    <button onclick="updateMethodChoice(1)" id="linear">linear solver</button>
    <button onclick="updateMethodChoice(2)" id="characteristic">
      characteristic solver
    </button>
    <div>
      <p>liquid speed</p>
      <button onclick="updateDirection(3)" id="direction_3">Sud</button>
      <button onclick="updateDirection(4)" id="direction_4">Est</button>
      <button onclick="updateDirection(5)" id="direction_5">Nord</button>
      <button onclick="updateDirection(6)" id="direction_6">Ouest</button>
    </div>
    <input
      type="range"
      min="1"
      max="20"
      value="10"
      class="slider"
      oninput="updateSpeed(this.value)"
    />
    <!-- results -->
    <div style="display: flex">
      <canvas
        class="ffjs_graph"
        data-ffjs="figure.eps"
        width="500px"
        height="500px"
        style="width: 100%"
      >
        (message for older browsers where canvas is not implemented)
      </canvas>
      <canvas
        class="ffjs_graph"
        data-ffjs="default"
        width="500px"
        height="500px"
        style="width: 100%"
      >
        (message for older browsers where canvas is not implemented)
      </canvas>
    </div>
    <div id="ffjs_stdout" style="font-family: monospace"></div>
    <div id="ffjs_stderr" style="font-family: monospace"></div>

    <div id="askPermission">
      <div class="modal-content">
        <p>This page needs to load a solver for differential equations.</p>
        <p>
          60MB will be loaded, we recommend you to use WIFI instead of 3G, 4G or
          even 5G.
        </p>
        <button onclick="loadLibraries()">
          load this big file<br />
          &lt;3
        </button>
      </div>
    </div>

    <script>
      function updatPenSize(val) {
        penSize = val;
        var penShape = document.getElementById("penSize").getContext("2d");
        penShape.clearRect(0, 0, 50, 50);
        penShape.beginPath();
        penShape.arc(25, 25, penSize, 0, Math.PI * 2, true);
        penShape.fill();
      }

      function updateMethodChoice(val) {
        choiceMethod = val;
        if (choiceMethod == 1) {
          document.getElementById("linear").className = "selected";
          document.getElementById("characteristic").className = "unselected";
        }
        if (choiceMethod == 2) {
          document.getElementById("linear").className = "unselected";
          document.getElementById("characteristic").className = "selected";
        }
      }

      function updateSpeed(val) {
        speed = val;
      }
      function updateDirection(val) {
        direction = val;
        [3, 4, 5, 6].forEach((x) => {
          if (direction === x) {
            document.getElementById(`direction_${x}`).className = "selected";
          } else {
            document.getElementById(`direction_${x}`).className = "unselected";
          }
        });
      }

      function loadLibraries() {
        const script1 = document.createElement("script");
        const script2 = document.createElement("script");
        document.head.appendChild(script1);
        document.head.appendChild(script2);
        script1.type = "text/javascript";
        script2.type = "text/javascript";
        script1.src = "lib/freefem.min.js";
        script2.src = "lib/ffapi.js";

        script1.onload = function (e) {
          // finish loading the script
          document.getElementById("askPermission").remove();
        };
      }

      var penSize;
      var choiceMethod;
      var direction;
      var speed;

      updatPenSize(10);
      updateMethodChoice(1);
      updateSpeed(10);
      updateDirection(3);

      var c = document.getElementById("inputCanvas");
      var ctx = c.getContext("2d");
      var points = [];

      var codeFreeFem = document.getElementById("buildShape");

      function getShape(points, curveIndex) {
        if (points.length <= 1) {
          return "";
        }
        const nbPoints = points.length;
        let totalDist = 0;
        const lastDist = Math.sqrt(
          (points[0].x - points[points.length - 1].x) ** 2 +
            (points[0].y - points[points.length - 1].y) ** 2
        );

        let rep = "";
        rep += `int choix = ${choiceMethod};  // Pour le choix du schéma`;

        usedDirections = [3, 4, 5, 6].filter((x) => x != direction);
        let Vx = 0;
        let Vy = 0;
        switch (direction) {
          case 3: // Sud
            Vy = -speed;
            break;
          case 4: // Est
            Vx = speed;
            break;
          case 5: // Nord
            Vy = speed;
            break;
          case 6: // Ouest
            Vx = -speed;
            break;
        }
        rep += `
              //choice of the direction
              int wall1 = ${usedDirections[0]};
              int wall2 = ${usedDirections[1]};
              int wall3 = ${usedDirections[2]};
              real Vx = ${Vx};
              real Vy = ${Vy};
      `;

        rep += `
                    real[int, int] Curves${curveIndex}(3, ${nbPoints + 1});


                    ${points
                      .map(({ x, y }, index) => {
                        if (index === 0) {
                          return `Curves${curveIndex}(0, 0) = ${(x + 0) / 10};
                    Curves${curveIndex}(1, 0) = ${(300 - y) / 10};
                    Curves${curveIndex}(2, 0) = 0.;

                        `;
                        } else {
                          const dx = x - points[index - 1].x;
                          const dy = y - points[index - 1].y;
                          const d = Math.sqrt(dx ** 2 + dy ** 2);
                          totalDist += d;
                          return `
                    Curves${curveIndex}(0, ${index}) = ${(x + 0) / 10};
                    Curves${curveIndex}(1, ${index}) = ${(300 - y) / 10};
                    Curves${curveIndex}(2, ${index}) = ${totalDist / 10};

                        `;
                        }
                      })
                      .join("")}

                    Curves${curveIndex}(0, ${points.length}) = ${
          (points[0].x + 0) / 10
        };
                    Curves${curveIndex}(1, ${points.length}) = ${
          (300 - points[0].y) / 10
        };
                    Curves${curveIndex}(2, ${points.length}) = ${
          (totalDist + lastDist) / 10
        };`;

        rep += `
              border jet${curveIndex}(t=0, 1)
             {
                int c=0;
                int i = 0;
                if( t== 1){
                    x = Curves${curveIndex}(0, ${nbPoints});
                    y = Curves${curveIndex}(1, ${nbPoints});
                }
                else{
                while(Curves${curveIndex}(2, i) <= Curves${curveIndex}(2, ${nbPoints}) * t ){
                    i += 1;
                }
                    x=(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, ${nbPoints})*t)/(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, i-1)) * Curves${curveIndex}(0, i-1) + (Curves${curveIndex}(2, ${nbPoints})*t - Curves${curveIndex}(2, i-1))/(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, i-1)) * Curves${curveIndex}(0, i);
                    y=(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, ${nbPoints})*t)/(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, i-1)) * Curves${curveIndex}(1, i-1) + (Curves${curveIndex}(2, ${nbPoints})*t - Curves${curveIndex}(2, i-1))/(Curves${curveIndex}(2, i) - Curves${curveIndex}(2, i-1)) * Curves${curveIndex}(1, i);

                }
                label=${curveIndex};
            }`;
        return rep;
      }

      function getShapes(listOfPoints) {
        let rep = "";

        let label = 1;
        const usedLabels = [];
        listOfPoints.forEach((points) => {
          const sol = getShape(
            points.map((_, i) => points[points.length - i - 1]),
            label
          );
          if (sol !== "") {
            usedLabels.push(label);
            label += 1;
            if (label == 3) {
              label = 7;
            }
            rep += sol;
          }
        });

        rep += `
              // Maillage pour les calculs
              Th = buildmesh(${usedLabels
                .map((l) => `jet${l}(-nbtj)`)
                .join(
                  "+"
                )}+C01(nbtbord)+C02(nbtbord)+C03(nbtbord)+C04(nbtbord));
              `;
        return rep;
      }

      const BODER_WIDTH = 10;
      c.onmousemove = function (ev) {
        if (ev.buttons === 1) {
          ctx.beginPath();
          ctx.arc(ev.layerX, ev.layerY, penSize, 0, Math.PI * 2, true);
          ctx.fill();
          ctx.clearRect(0, 0, BODER_WIDTH, 300);
          ctx.clearRect(0, 0, 300, BODER_WIDTH);
          ctx.clearRect(300 - BODER_WIDTH, 0, BODER_WIDTH, 300);
          ctx.clearRect(0, 300 - BODER_WIDTH, 300, BODER_WIDTH);
        }
      };

      function clearDrawing() {
        points = [];
        ctx.clearRect(0, 0, c.width, c.height);
      }

      function getIsoline() {
        const data = ctx.getImageData(0, 0, 300, 300).data;

        const newArr = [];
        for (let i = 0; i < data.length; i += 4 * 300) {
          newArr.push(
            Array.from(data.slice(i, i + 4 * 300)).filter(
              (x, index) => index % 4 === 3
            )
          );
        }
        const rep = MarchingSquaresJS.isoLines(newArr, [1, 100, 300], {
          noFrame: true,
        });

        return rep[1].map((l) => l.map(([x, y]) => ({ x, y })));
      }

      function run() {
        const listOfPoints = getIsoline();
        codeFreeFem.innerHTML = getShapes(listOfPoints);
        ffjs_evaluate();
      }
    </script>
  </body>
</html>
