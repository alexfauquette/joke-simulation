<!DOCTYPE html>
<html>
  <head>
    <script src="lib/jquery-1.11.2.min.js"></script>
    <script src="lib/freefem.min.js" type="text/javascript"></script>
    <script src="lib/ffapi.js" type="text/javascript"></script>
    <!-- <script src="lib/opencv.js" type="text/javascript"></script> -->
  </head>
  <body>
    <textarea class="ffjs">
      load "isoline"
        load "ppm2rnm"


// ========================================================
// Création du maillage
// ========================================================

// Paramètres
int nbtj=50; // Nb de triangles autour des avions
int nbtbord=10; // Nb de triangles aux bords du domaine


int nx = 31;
int ny = 31;
    
// Maillage pour isoline
mesh Th = square(nx-1, ny-1, [(nx-1)*(x), (ny-1)*(1-y)]);

// Fespace
fespace Vh(Th, P1);





border C01(t=0, 1){x = t*(nx-1);y = 0;label=3;}  // Sud
border C02(t=0, 1){x = nx-1;y = t*(ny-1);label=4;}  // Est
border C03(t=0, 1){x = (1-t)*(nx-1);y = (ny-1);label=5;}  // Nord
border C04(t=0, 1){x = 0;y = (1-t)*(ny-1);label=6;}  // Ouest



</textarea
    >
    <textarea id="buildShape" class="ffjs"> </textarea>
    <textarea class="ffjs">

//border jet1(t=0, 1)
//{
//    int c=0;
//    int i0=be[2*c], i1=be[2*c+1]-1;
//    P=Curve(Curves, i0, i1, t);
//    label=1;
//}
border jet1(t=0, 1)
 {
    int c=0;
    int i0=be[2*c], i1=be[2*c+1]-1;
    int i = i0;
    if( t== 1){
        x = Curves(0, i1);
        y = Curves(1, i1);
    }
    else{
    while(Curves(2, i) <= Curves(2, i1) * t ){
        i += 1;
    }
        x=(Curves(2, i) - Curves(2, i1)*t)/(Curves(2, i) - Curves(2, i-1)) * Curves(0, i-1) + (Curves(2, i1)*t - Curves(2, i-1))/(Curves(2, i) - Curves(2, i-1)) * Curves(0, i);
        y=(Curves(2, i) - Curves(2, i1)*t)/(Curves(2, i) - Curves(2, i-1)) * Curves(1, i-1) + (Curves(2, i1)*t - Curves(2, i-1))/(Curves(2, i) - Curves(2, i-1)) * Curves(1, i);

    }
    
    label=1;
}


// Maillage pour les calculs
Th = buildmesh(jet1(-nbtj)+C01(nbtbord)+C02(nbtbord)+C03(nbtbord)+C04(nbtbord));


plot(Th, ps="figure.eps");




// ========================================================
// Résolution du problème
// ========================================================

// Paramètres
// real nu = 1.56e-5;
real nu = 1.;
real dt = 0.1;
real T = 1.;  // Temps final
int i;
int choix = 2;  // Pour le choix du schéma

// Fespace
fespace Uh(Th,P2);  // Espace pour la vélocité
Uh u1, u2, v1, v2;
Uh u1old, u2old;

fespace Ph(Th,P1);  // Espace pour la pression
Ph p, q;

// Problème de Navier-Stokes
// Par linéarisation
problem NavierStokes1(u1, u2, p, v1, v2, q, solver=Crout, init = i)
    =   int2d(Th)
        (
                (u1*v1 + u2*v2)/dt
            +   nu*(dx(u1)*dx(v1) + dy(u1)*dy(v1)
                +   dx(u2)*dx(v2) + dy(u2)*dy(v2))
            - p*dx(v1) - p*dy(v2)
            - q*dx(u1) - q*dy(u2)
            - p*q*(0.000001)  // Pour la stabilité et permet d'utiliser le solveur Crout
        )
      + int2d(Th)
        (
            - u1old*v1/dt - u2old*v2/dt
        )
      + int2d(Th)
        (
            u1old*(dx(u1)*v1 + dy(u1)*v2)
            + u2old*(dx(u2)*v1 + dy(u2)*v2)
        )
      + on(1, 2, u1=0, u2=0)  // Conditions de Dirichlet sur les avions
      + on(4,5,6, u1=0, u2=-10)  // Conditions de Dirichlet à l'Est, au Nord et à l'Ouest
    ;

// Méthode des caractéristiques
problem NavierStokes2(u1, u2, p, v1, v2, q, solver = Crout, init = i)
    =   int2d(Th)
        (
                (u1*v1 + u2*v2)/dt
            +   nu*(dx(u1)*dx(v1) + dy(u1)*dy(v1)
                +   dx(u2)*dx(v2) + dy(u2)*dy(v2))
            - p*dx(v1) - p*dy(v2)
            - q*dx(u1) - q*dy(u2)
            - p*q*(0.000001)  // Pour la stabilité et permet d'utiliser le solveur Crout
        )
      + int2d(Th)
        (
            -   convect([u1old, u2old], -dt, u1old)*v1/dt
            -   convect([u1old, u2old], -dt, u2old)*v2/dt
        )
      + on(1, 2, u1=0, u2=0)  // Conditions de Dirichlet sur les avions
      + on(4,5,6, u1=0, u2=-10)  // Conditions de Dirichlet à l'Est, au Nord et à l'Ouest
    ;


// Boucle pour le temps
u1 = 0;
u2 = 0;
p=0;

i = 0;
for (real t = 0; t <= T; t += dt)
{
    if (i%10 == 0) i=0;  // On recalcule la matrice tous les 10 pas de temps
    if (choix == 1)
    {
        u1old = u1;
        u2old = u2;
        NavierStokes1;           
    }
        
    else if (choix == 2)
    {
        u1old = u1;
        u2old = u2;
        NavierStokes2;
    }
    i++;
}
plot([u1,u2],p, cmm="t = "+T, value=1);




    </textarea>

    <button type="button" onclick="ffjs_evaluate()">Run</button>
    <button type="button" onclick="clearDrawing()">Clear</button>
    <!-- <button type="button" onclick="ffjs_reset()">Reset</button> -->

    <canvas
      id="inputCanvas"
      style="border: 2px solid red"
      width="300px"
      height="300px"
    ></canvas>

    <div style="display: flex">
      <canvas
        class="ffjs_graph"
        data-ffjs="figure.eps"
        width="500px"
        height="500px"
        style="width: 100%"
      >
        (message for older browsers where canvas is not implemented)
      </canvas>
      <canvas
        class="ffjs_graph"
        data-ffjs="default"
        width="500px"
        height="500px"
        style="width: 100%"
      >
        (message for older browsers where canvas is not implemented)
      </canvas>
    </div>
    <div id="ffjs_stdout" style="font-family: monospace"></div>
    <div id="ffjs_stderr" style="font-family: monospace"></div>

    <script>
      var c = document.getElementById("inputCanvas");
      var ctx = c.getContext("2d");
      var points = [];

      var codeFreeFem = document.getElementById("buildShape");

      function getShapes(points) {
        if (points.length <= 1) {
          return "";
        }
        const nbPoints = points.length;
        let totalDist = 0;
        const lastDist = Math.sqrt(
          (points[0].x - points[points.length - 1].x) ** 2 +
            (points[0].y - points[points.length - 1].y) ** 2
        );

        const rep = `real[int, int] Curves(3, ${nbPoints + 1});
        int[int] be(2);
        be(0) = 0;
        be(1) = ${nbPoints + 1};

        ${points
          .map(({ x, y }, index) => {
            if (index === 0) {
              return `Curves(0, 0) = ${(x + 5) / 10};
        Curves(1, 0) = ${(305 - y) / 10};
        Curves(2, 0) = 0.;

            `;
            } else {
              const dx = x - points[index - 1].x;
              const dy = y - points[index - 1].y;
              const d = Math.sqrt(dx ** 2 + dy ** 2);
              totalDist += d;
              return `
        Curves(0, ${index}) = ${(x + 5) / 10};
        Curves(1, ${index}) = ${(305 - y) / 10};
        Curves(2, ${index}) = ${totalDist / 10};

            `;
            }
          })
          .join("")}

        Curves(0, ${points.length}) = ${(points[0].x + 5) / 10};
        Curves(1, ${points.length}) = ${(305 - points[0].y) / 10};
        Curves(2, ${points.length}) = ${(totalDist + lastDist) / 10};

        `;

        return rep;
      }

      c.onmousedown = function (ev) {
        ctx.beginPath();
        ctx.arc(ev.layerX, ev.layerY, 3, 0, Math.PI * 2, true);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(ev.layerX, ev.layerY);
        if (points.length > 0) {
          ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
          ctx.stroke();
        }
        points.push({ x: ev.layerX, y: ev.layerY });

        codeFreeFem.innerHTML = getShapes(points);
      };

      c.onmousemove = function (ev) {
        if (points.length == 0) {
          return null;
        }
        ctx.clearRect(0, 0, c.width, c.height);

        ctx.beginPath();
        ctx.strokeStyle = "green";
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 0; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
          ctx.arc(points[i].x, points[i].y, 3, 0, Math.PI * 2, true);
        }
        ctx.closePath();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(ev.layerX, ev.layerY);
        ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);

        ctx.strokeStyle = "red";

        ctx.stroke();
      };
      c.onmouseleave = function () {
        ctx.clearRect(0, 0, c.width, c.height);
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 0; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
        ctx.fill();
      };

      function clearDrawing() {
        points = [];
        ctx.clearRect(0, 0, c.width, c.height);
      }
    </script>
  </body>
</html>
